"""Module demonstrating the use of Catalyst for in-situ visualization"""
##############################################################################
# A simple simulator for a 2D problem, with an in-situ coupling
# The data generation parameters for the vector field
# come from https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/examples.html
# using Catalyst https://catalyst-in-situ.readthedocs.io/en/latest/index.html
#
# Author: Jean M. Favre, Swiss National Supercomputing Center
#
# this serial version runs until completion and saves images of the scalar field
# at regular intervals.
#
# run: python3 double_gyre_catalyst.py
#
# Tested with Python 3.12.3, Mon 11 Sep 13:42:19 CEST 2023
#
##############################################################################
import math
import numpy as np
import catalyst
import catalyst_conduit as conduit
import catalyst_conduit.blueprint
import matplotlib.pyplot as plt

class Simulation:
    """
    An animated vector field generated by a math expression

    Attributes
    ----------
    resolution : int, int
        the number of grid points on the I and J axis
    iterations : int
        the maximum number of iterations (default 100)
    """
    def __init__(self, resolution=(256,128), iterations=10):
        self.iteration = 0
        self.timestep = 0.1
        self.max_iterations = iterations

        self.xres = resolution[0] # X horizontal resolution
        self.yres = resolution[1] # Y vertical   resolution
        self.xaxis = np.linspace(0., 2., self.xres)
        self.yaxis = np.linspace(0., 1., self.yres)
        self.zaxis = np.linspace(0., 0., 1)
        self.x_coord, self.y_coord = np.meshgrid(self.xaxis, self.yaxis, indexing="xy")

        self.vel_x = np.zeros(self.xres * self.yres, dtype=np.float64)
        self.vel_y = np.zeros(self.xres * self.yres, dtype=np.float64)
        self.vel_z = np.zeros(self.xres * self.yres, dtype=np.float64)
        self.A = 0.1 * np.pi
        self.w = 2.0 * np.pi / 10.
        self.E = 0.25

    def compute_onestep(self):
        At = self.E * np.sin(self.w * self.iteration * self.timestep)
        Bt = 1.0 - 2.0 * At
        Ft = (At * self.x_coord * self.x_coord + Bt * self.x_coord) * np.pi
        fft = 2.0 * At * self.x_coord + Bt
        self.vel_x = -self.A * np.sin(Ft) * np.cos(np.pi * self.y_coord)
        self.vel_y =  self.A * np.cos(Ft) * np.sin(np.pi * self.y_coord) * fft
        self.iteration += 1

    def compute_loop(self):
        """Computes and updates velocity fields"""
        while self.iteration < self.max_iterations:
            self.compute_onestep()

    def draw_matplotlib(self):
        """Draw with mathplotlib"""
        #plot the 'vel_x' field iso-contour lines
        fig, ax = plt.subplots()
        CS = ax.contour(self.vel_x, levels=10)
        ax.clabel(CS, inline=True, fontsize=10)
        ax.set_title('Vx iso-contours')
        plt.savefig(f'Vx-iso-contours.{self.iteration:03d}.png')
        #plot the velocity vectors sub-sampled
        fig1, ax1 = plt.subplots()
        stride = 10
        ax1.quiver(self.x_coord[::stride, ::stride], self.y_coord[::stride, ::stride],
                   self.vel_x[::stride, ::stride], self.vel_y[::stride, ::stride])
        ax1.set_title('Velocity vectors')
        plt.savefig(f'Velocity.{self.iteration:03d}.png')

class SimulationWithCatalyst(Simulation):
    """
    A specialized class to add in-situ visualization support

    Attributes
    ----------

    """
    def __init__(self, resolution=(256,128), iterations=10, pv_script="pvDoubleGyre.py"):
        Simulation.__init__(self, resolution, iterations)
        self.delta_x = 2.0 / (self.xres - 1)
        self.insitu = conduit.Node()
        self.pv_script = pv_script
        self.initialize_catalyst()
        
        self.exec_params = conduit.Node()
        
    def Initialize(self):
        channel = self.exec_params["catalyst/channels/grid"]
        channel["type"] = "mesh"
        mesh = channel["data"]
        meshType = "uniform"
        
        if meshType == "uniform":
            mesh["coordsets/coords/type"] = "uniform"
            mesh["coordsets/coords/dims/i"] = self.xres
            mesh["coordsets/coords/dims/j"] = self.yres
            mesh["coordsets/coords/dims/k"] = 1

            mesh["topologies/mesh/type"] = "uniform"
            mesh["topologies/mesh/coordset"] = "coords"

            mesh["coordsets/coords/origin/x"] = 0.0
            mesh["coordsets/coords/origin/y"] = 0.0
            mesh["coordsets/coords/origin/z"] = 0.0
            mesh["coordsets/coords/spacing/dx"] = self.delta_x
            mesh["coordsets/coords/spacing/dy"] = self.delta_x
            mesh["coordsets/coords/spacing/dz"] = self.delta_x
        elif meshType == "rectilinear":
            mesh["coordsets/coords/type"] = "rectilinear"
            mesh["coordsets/coords/values/x"].set_external(self.xaxis)
            mesh["coordsets/coords/values/y"].set_external(self.yaxis)
            #mesh["coordsets/coords/values/z"].set_external(self.zaxis)
            mesh["topologies/mesh/type"] = "rectilinear"
            mesh["topologies/mesh/coordset"] = "coords"

        mesh["fields/vel_x/association"] = "vertex"
        mesh["fields/vel_x/topology"] = "mesh"
        mesh["fields/vel_x/values"].set_external(self.vel_x)

        mesh["fields/vel_y/association"] = "vertex"
        mesh["fields/vel_y/topology"] = "mesh"
        mesh["fields/vel_y/values"].set_external(self.vel_y)

        mesh["fields/Velocity/association"] = "vertex"
        mesh["fields/Velocity/topology"] = "mesh"
        mesh["fields/Velocity/values/u"].set_external(self.vel_x)
        mesh["fields/Velocity/values/v"].set_external(self.vel_y)
        mesh["fields/Velocity/values/w"].set_external(self.vel_z)

        # verify the mesh we created conforms to the blueprint
        verify_info = conduit.Node()
        if not conduit.blueprint.mesh.verify(mesh, verify_info):
          print("DoubleGyre Mesh Verify failed!")
          print(verify_info)
        else:
            pass
            #print(mesh)
              #print("DoubleGyre Mesh verify success!")

    def compute_loop(self):
        """Computes and updates velocity fields"""
        while self.iteration < self.max_iterations:
            self.compute_onestep()
            #self.iteration += 1
            state = self.exec_params["catalyst/state"]
            state["timestep"] = self.iteration
            state["time"] = self.iteration * 0.1
            catalyst.execute(self.exec_params)

    def initialize_catalyst(self):
        """Creates a Conduit node """
        self.insitu["catalyst/scripts/script/filename"] = self.pv_script
        self.insitu["catalyst_load/implementation"] = "paraview"

        # open Catalyst
        catalyst.initialize(self.insitu)

    def finalize_catalyst(self):
        """close"""
        print(self.exec_params["catalyst/channels/grid/data"])
        catalyst.finalize(self.insitu)

#sim = Simulation()
sim = SimulationWithCatalyst(iterations=10, pv_script="pvDoubleGyre.py")
sim.Initialize()
sim.compute_loop()
sim.draw_matplotlib()
sim.finalize_catalyst()
