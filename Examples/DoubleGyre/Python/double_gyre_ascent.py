"""Module demonstrating the use of Ascent for in-situ visualization"""
##############################################################################
# A simple simulator for a 2D problem, with an in-situ coupling
# The data generation parameters for the vector field
# come from https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/examples.html
# with the Ascent library https://ascent.readthedocs.io/en/latest/#
#
# Author: Jean M. Favre, Swiss National Supercomputing Center
#
# this serial version runs until completion and saves images of the scalar field
# at regular intervals. It saves the final solution to a blueprint HDF5 file
#
# run: python3 double_gyre_ascent.py
#
# Tested with Python 3.10.6, Fri Feb 17 03:03:14 PM CET 2023
#
##############################################################################
import math
import numpy as np
import conduit
import conduit.blueprint
import ascent
import matplotlib.pyplot as plt

class Simulation:
    """
    An animated vector field generated by a math expression

    Attributes
    ----------
    resolution : int, int
        the number of grid points on the I and J axis
    iterations : int
        the maximum number of iterations (default 100)
    """
    def __init__(self, resolution=(256,128), iterations=100):
        self.iteration = 0
        self.timestep = 0.1
        self.max_iterations = iterations

        self.xres = resolution[0] # X horizontal resolution
        self.yres = resolution[1] # Y vertical   resolution
        xaxis = np.linspace(0., 2., self.xres)
        yaxis = np.linspace(0., 1., self.yres)
        self.x_coord, self.y_coord = np.meshgrid(xaxis, yaxis, indexing="xy")

        self.vel_x = np.zeros(self.x_coord.shape)
        self.vel_y = np.zeros(self.x_coord.shape)
        self.vel_z = np.zeros(self.x_coord.shape)
        self.A = 0.1 * np.pi
        self.w = 2.0 * np.pi/10.
        self.E = 0.25

    def compute_loop(self):
        """Computes and updates velocity fields"""
        while self.iteration < self.max_iterations:
            At = self.E * math.sin(self.w * self.iteration * self.timestep)
            Bt = 1.0 - 2.0 * At
            Ft = (At * self.x_coord*self.x_coord + Bt * self.x_coord) * np.pi
            fft = 2.0 * At * self.x_coord + Bt
            self.vel_x = -self.A * np.sin(Ft) * np.cos(np.pi*self.y_coord)
            self.vel_y =  self.A * np.cos(Ft) * np.sin(np.pi*self.y_coord)*fft
            self.iteration += 1

    def draw_matplotlib(self):
        """Draw with mathplotlib"""
        #plot the 'vel_x' field iso-contour lines
        fig, ax = plt.subplots()
        CS = ax.contour(self.vel_x, levels=10)
        ax.clabel(CS, inline=True, fontsize=10)
        ax.set_title('Vx iso-contours')
        plt.savefig(f'Vx-iso-contours.{self.iteration:03d}.png')
        #plot the velocity vectors sub-sampled
        fig1, ax1 = plt.subplots()
        stride = 10
        ax1.quiver(self.x_coord[::stride, ::stride], self.y_coord[::stride, ::stride],
                   self.vel_x[::stride, ::stride], self.vel_y[::stride, ::stride])
        ax1.set_title('Velocity vectors')
        plt.savefig(f'Velocity.{self.iteration:03d}.png')

class SimulationWithAscent(Simulation):
    """
    A specialized class to add in-situ visualization support

    Attributes
    ----------
    frequency : int
        the frequency at which in-situ operations take place
    """
    def __init__(self, resolution=(256,128), iterations=100, frequency=10):
        Simulation.__init__(self, resolution, iterations)
        self.delta_x = 2.0 / (self.xres - 1)
        self.frequency = frequency
        self.insitu = ascent.Ascent()
        self.actions = conduit.Node()
        self.mesh = conduit.Node()

    def compute_loop(self):
        """Computes and updates velocity fields and process in-situ requests"""
        while self.iteration < self.max_iterations:
            At = self.E * math.sin(self.w * self.iteration * self.timestep)
            Bt = 1.0 - 2.0 * At
            Ft = (At * self.x_coord*self.x_coord + Bt * self.x_coord) * np.pi
            fft = 2.0 * At * self.x_coord + Bt
            self.vel_x = -self.A * np.sin(Ft) * np.cos(np.pi*self.y_coord)
            self.vel_y =  self.A * np.cos(Ft) * np.sin(np.pi*self.y_coord)*fft
            self.iteration += 1

            if not self.iteration % self.frequency:
                self.mesh["state/cycle"] = self.iteration
                self.scenes["s1/renders/r1/image_name"] = f'vel_mag.{self.iteration:03d}'
                self.scenes["s2/renders/r1/image_name"] = f'vort_mag.{self.iteration:03d}'
                self.insitu.publish(self.mesh)
                self.insitu.execute(self.actions)

    def initialize_ascent(self):
        """Creates a Conduit node describing the mesh and add default action"""
        ascent_opts = conduit.Node()
        ascent_opts["exceptions"] = "forward"
        # open Ascent
        self.insitu.open(ascent_opts)

        self.mesh["coordsets/coords/type"] = "uniform"
        self.mesh["coordsets/coords/dims/i"] = self.xres
        self.mesh["coordsets/coords/dims/j"] = self.yres

        self.mesh["topologies/mesh/type"] = "uniform"
        self.mesh["topologies/mesh/coordset"] = "coords"

        self.mesh["coordsets/coords/origin/x"] = 0.0
        self.mesh["coordsets/coords/origin/y"] = 0.0
        self.mesh["coordsets/coords/spacing/dx"] = self.delta_x
        self.mesh["coordsets/coords/spacing/dy"] = self.delta_x

        self.mesh["fields/vel_x/association"] = "vertex"
        self.mesh["fields/vel_x/topology"] = "mesh"
        self.mesh["fields/vel_x/values"].set_external(self.vel_x.ravel())

        self.mesh["fields/vel_y/association"] = "vertex"
        self.mesh["fields/vel_y/topology"] = "mesh"
        self.mesh["fields/vel_y/values"].set_external(self.vel_y.ravel())

        self.mesh["fields/Velocity/association"] = "vertex"
        self.mesh["fields/Velocity/topology"] = "mesh"
        self.mesh["fields/Velocity/values/u"].set_external(self.vel_x.ravel())
        self.mesh["fields/Velocity/values/v"].set_external(self.vel_y.ravel())
        self.mesh["fields/Velocity/values/w"].set_external(self.vel_z.ravel())

        # verify the mesh we created conforms to the blueprint
        verify_info = conduit.Node()
        if not conduit.blueprint.mesh.verify(self.mesh, verify_info):
            print("DoubleGyre Mesh Verify failed!")
        else:
            print("DoubleGyre Mesh verify success!")
            #print(self.mesh.to_yaml())

        self.add_act = self.actions.append()
        self.add_act["action"] = "add_pipelines"
        self.pipelines = self.add_act["pipelines"]
        self.pipelines["pl1/f1/type"] = "vector_magnitude"
        self.pipelines["pl1/f1/params/field"] = "Velocity"
        self.pipelines["pl1/f1/params/output_name"] = "velocity_mag2d"

        self.pipelines["pl2/f1/type"] = "vorticity"
        self.pipelines["pl2/f1/params/field"] = "Velocity"
        self.pipelines["pl2/f1/params/output_name"] = "Mvorticity"
        
        self.pipelines["pl2/f2/type"] = "vector_magnitude"
        self.pipelines["pl2/f2/params/field"] = "Mvorticity"
        self.pipelines["pl2/f2/params/output_name"] = "vorticity_mag"

        self.add_act = self.actions.append()
        self.add_act["action"] = "add_scenes"

        self.scenes = self.add_act["scenes"]
        self.scenes["s1/plots/p1/type"] = "pseudocolor"
        self.scenes["s1/plots/p1/pipeline"] = "pl1"
        self.scenes["s1/plots/p1/field"] = "velocity_mag2d"

        self.scenes = self.add_act["scenes"]
        self.scenes["s2/plots/p1/type"] = "pseudocolor"
        self.scenes["s2/plots/p1/pipeline"] = "pl2"
        self.scenes["s2/plots/p1/field"] = "vorticity_mag"

    def finalize_ascent(self):
        """Save the mesh to a blueprint HDF5 file and close"""
        self.mesh["state/cycle"] = self.iteration
        self.insitu.publish(self.mesh)
        hdf5_action = conduit.Node()
        add_extr = hdf5_action.append()
        # to save the derived vector magnitude, add the pipeline first
        add_extr["action"] = "add_pipelines"
        pipeline = add_extr["pipelines"]
        pipeline["pl1/f1/type"] = "vector_magnitude"
        pipeline["pl1/f1/params/field"] = "Velocity"
        pipeline["pl1/f1/params/output_name"] = "velocity_mag2d"

        add_extr = hdf5_action.append()
        add_extr["action"] = "add_extracts"
        extracts = add_extr["extracts"]
        extracts["e1/type"]="relay"
        extracts["e1/params/path"] = "/dev/shm/mesh"
        extracts["e1/pipeline"] = "pl1"
        extracts["e1/params/protocol"] = "blueprint/mesh/hdf5"

        self.insitu.execute(hdf5_action)
        self.insitu.close()

#sim = Simulation()
sim = SimulationWithAscent(iterations=100, frequency=10)
sim.initialize_ascent()
sim.compute_loop()
sim.draw_matplotlib()
sim.finalize_ascent()
