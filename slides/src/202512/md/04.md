---
layout: section
---

# Use cases with Ascent

---
level: 2
---

## Instrument an SPH simulation code with Ascent
<br>

- The smooth particle hydrodynamics (SPH) technique is a purely Lagrangian
method. 
- SPH discretizes a fluid in a series of interpolation points whose
distribution follows the mass density of the fluid.
    - [PASC], the Swiss Platform for Advanced Scientific Computing initiative,
    supports the SPH-EXA project developing an SPH library.
    - [SPH-EXA] is a C++20 headers-only code with no external software
    dependencies. The parallelism is currently expressed via the following
    models: MPI, OpenMP, CUDA and HIP.

[PASC]: https://www.pasc-ch.org/
[SPH-EXA]: https://github.com/sphexa-org/sphexa.git

---
level: 2
---

## Instrument an SPH simulation code with Ascent
<br>

- Define a Conduit **[mesh]** definition

- Define a Conduit **[scene]** definition

- About 150 lines of code.

[mesh]: https://github.com/unibas-dmi-hpc/SPH-EXA/blob/develop/main/src/ascent_adaptor.h#L142
[scene]: https://github.com/unibas-dmi-hpc/SPH-EXA/blob/develop/main/src/ascent_adaptor.h#L30

---
level: 2
---

## Conduit's definition of the coordinates of the particle set

```python
particle_set = """
  coordsets:
  coords:
  type: "explicit"
  values:
    x: [0.0, 10.0, 20.0, 30.0]
    y: [0.0, 10.0, 20.0, 30.0]
    z: [0.0, 10.0, 20.0, 30.0]
 """
```

```c
conduit::Node mesh;

mesh["state/cycle"].set_external(&d.iteration);
mesh["state/time"].set_external(&d.ttot);
mesh["coordsets/coords/type"] = "explicit";

mesh["coordsets/coords/values/x"].set_external(&d.x);
mesh["coordsets/coords/values/y"].set_external(&d.y);
mesh["coordsets/coords/values/z"].set_external(&d.z);
// The heavy-data is available via shallow-copy links
```

---
level: 2
---

## Add the definition of the  topology

```yaml
particle_set = """
   topologies:
     mesh:
       type: "unstructured"
       elements:
       shape: "point"
       connectivity: [0, 1, 2, 3]
       coordset: "coords"
"""
```

```c
mesh["topologies/mesh/type"].set("unstructured");
mesh["topologies/mesh/elements/shape"].set("point");
mesh["topologies/mesh/coordset"].set("coords");

std::vector<conduit_int32> conn(N); // N is # of particles
std::iota(conn.begin(), conn.end(), 0);
mesh["topologies/mesh/elements/connectivity"].set_external(conn);
```

---
level: 2
---

## Add the definition of the dependent variables

```python
particle_set = """
 fields:
   rho:
    association: "vertex"
    values: [-1, -2, -3, -4]
    topology: "mesh"
    volume_dependent: "false"
    units: "g/cc"
"""
```

```c
auto fields = mesh["fields"];

// Density scalar field:
fields["rho/association"].set("vertex");
fields["rho/topology"].set("mesh");
fields["rho/volume_dependent"].set("false");

// Conduit supports shallow copy
fields["rho/values"].set_external(&d.rho);
```

---
level: 2
---

## Sanity check

Use Conduit's Blueprint to **validate** the particle mesh

```python
import conduit
import conduit.blueprint as blueprint
mesh = conduit.Node()
ps1 = """
coordsets: 
  coords: 
    type: "explicit"
    values: 
      x: [0.0, 10.0, 20.0, 30.0]
topologies: 
  mesh: 
    type: "points"
    coordset: "coords"
fields: 
  rho: 
    association: "vertex"
    values: [-1, -2, -3, -4]
    topology: "mesh"
"""
mesh.parse(ps1,"yaml")
info = conduit.Node()
blueprint.verify("mesh", mesh, info)
```

---
level: 2
---

## SPH-EXA can simulate different scenarios

They differ in terms of spatial bounds, availability of dependent variables, range of data, etc..
<br>

Strategy:
- hard-code a trivial "hello-world" example in the Ascent actions at compile time<br>
- override it at run-time with a file called [ascent_actions.yaml](https://ascent.readthedocs.io/en/latest/AscentAPI.html#open)<br>
- Special case: SPH-EXA uses [sphexa_Ascent_actions.yaml](https://github.com/sphexa-org/sphexa/blob/develop/main/src/ascent_adaptor.h#L35)
- quick prototyping of actions files with [replay](https://ascent.readthedocs.io/en/latest/Utilities.html#replay)<br>
- and [don't forget yamllint][url_yamllint]<br>

[url_yamllint]: https://www.yamllint.com/
---
level: 2
---

## Get some sample data to test multiple scenarios

Strategy:
- Dump example output file(s) to disk using [Ascent relay](https://ascent.readthedocs.io/en/latest/Actions/Extracts.html#relay)

```yaml
---
-
  action: "add_extracts"
  extracts:
    e1:
      type: "relay"
      params:
        path: "datasets/relay_output"
        protocol: "hdf5"
```
- see example output (files relay_output.cycle*root)
```c
cd /capstor/scratch/cscs/jfavre/SPH-EXA/Ascent/datasets
```
- see example YAML scene definitions
```c
cd /users/jfavre/Projects/SPH-EXA/YAML
```
---
level: 2
---
## quick prototyping of actions files with ascent_replay

Strategy:
- test and try different actions with the small resolution data

```c
ssh -L 8888:localhost:8888 daint
uenv start insitu_ascent/0.9.5:2109123735 --view=default

ls -C1 relay_output.cycle_00* > cycles_list.txt
mkdir datasets
export PATH=/user-tools/linux-neoverse_v2/ascent-0.9.5-5tvprek3v4ttm22u6huvwqqekdfu3h3v/utilities/ascent/replay/:$PATH
<path>/ascent_replay --cycles=cycles_list.txt --actions=../sphexa_Ascent_threshold_sedov.yaml
ls -l datasets/kx.*png
python3 -m http.server 8888
```
---
level: 2
---
## An advanced example with query/expressions

```yaml
-
  action: "add_queries"
  queries:
    q00:
      params:
        expression: "field('kx') * field('m') / field('xm')"
        name: "density"
    q01:
      params:
        expression: |
          R = (field('x') * field('x')) + (field('y') * field('y')) + (field('z') * field('z'));
          sqrt(R)
        name: "radius"
    q1:
      params:
        expression: "binning('density', 'pdf', [axis('radius',num_bins=256), axis('density', num_bins=256)])
"
        name: "pdf_density"
    q2:
      params:
        expression: "binning('density', 'max', [axis('radius', num_bins=256)])"
        name: "max_density"
```
---
level: 2
---
## Ascent Derived quantities

Calculate a Probability Density Function, density = f(radius)

- evaluate radius = sqrt(x^2 + y^2 + z^2)
- evaluate density = kx * m / xm ( these 3 variables are contained in the Conduit description)
- use Ascent's [Data Binning] 
- Ascent uses OCCA for JIT compilation

<div class="grid grid-cols-[33%_33%_33%] gap-1">
<div> <!-- #left -->
<img src="/img/pdf_density_256x256.t=500.png" style="width: 10vw; min-width: 250px;">
<br>
</div>
<div> <!-- #center -->
<img src="/img/pdf_density_256x256.t=1000.png" style="width: 10vw; min-width: 250px;">
<br>
</div>
<div> <!-- #right -->
<img src="/img/pdf_density_256x256.t=1500.png" style="width: 10vw; min-width: 250px;">
<br>
</div>
</div>

[Data Binning]: https://ascent.readthedocs.io/en/latest/Actions/Binning.html#binning
---

###

<div class="grid grid-cols-[50%_50%] gap-1">
<div> <!-- #left -->

### OpenMP code generation
<br>

<Transform :scale="0.9">
```cpp
#include <occa.hpp>

using namespace std;
using namespace occa;

extern "C" void map(double * output,
                    const double * z,
                    const double * x,
                    const double * y,
                    const int & entries) {
#pragma omp parallel for
  for (int group = 0; group < entries; group += 128) {
    for (int item = group; item < (group + 128); ++item) {
      if (item < entries) {
        output[item] = sqrt(
          (((x[item] * x[item]) + \
            (y[item] * y[item])) + \
            (z[item] * z[item]))
        );
      }
    }
  }
}
```
</Transform>
</div>

<div> <!-- #right -->

### CUDA code generation
<br>

<Transform :scale="0.9">
```cpp
extern "C" __global__ void _occa_map_0(double * output,
                                         const double * z,
                                         const double * x,
                                         const double * y,
                                         const int entries) {
  {
    int group = 0 + (128 * blockIdx.x);
    {
      int item = group + threadIdx.x;
      if (item < entries) {
        output[item] = sqrt(
          (((x[item] * x[item])  + \
            (y[item] * y[item]))  + \
            (z[item] * z[item]))
        );
      }
    }
  }
}

```
</Transform>
</div>
</div>

---
level: 2
---

## Instrument a mini Heat Diffusion example with Ascent
<br>
- Visit [Heat Diffusion](https://github.com/jfavre/InSitu-Vis-Tutorial/Examples/HeatDiffusion) example<br>
- Inspect AscentAdaptor.h


```
uenv start insitu_ascent/0.9.5:2109123735 --view=default

cmake -S . -B buildAscent -DINSITU=Ascent

cmake --build buildAscent

srun -u -n 4 -pdebug -t 2 ./buildAscent/bin/heat_diffusion --mesh=uniform --res=64
```
