"""Module demonstrating the use of Ascent for in-situ visualization"""
##############################################################################
# A simple simulator for a 2D problem, with an in-situ coupling
# The data generation parameters for the vector field
# come from https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/examples.html
# with the Ascent library https://ascent.readthedocs.io/en/latest/#
#
# Author: Jean M. Favre, Swiss National Supercomputing Center
#
# this serial version runs until completion and saves images of the scalar field
# at regular intervals. It saves the final solution to a blueprint HDF5 file
#
# run: python3 double_gyre_ascent.py
#
# Tested with Python 3.12.3, Wed 12 Nov 10:23:39 CET 2025
#
##############################################################################
import os
import math
import numpy as np
import conduit
import conduit.blueprint
import ascent
import matplotlib.pyplot as plt

class Simulation:
    """
    An animated vector field generated by a math expression

    Attributes
    ----------
    resolution : int, int
        the number of grid points on the I and J axis
    iterations : int
        the maximum number of iterations (default 100)
    """
    def __init__(self, resolution=(256,128), iterations=100):
        self.iteration = 0
        self.timestep = 0.1
        self.max_iterations = iterations

        self.xres = resolution[0] # X horizontal resolution
        self.yres = resolution[1] # Y vertical   resolution
        xaxis = np.linspace(0.0, 2.0, self.xres)
        yaxis = np.linspace(0.0, 1.0, self.yres)
        self.x_coord, self.y_coord = np.meshgrid(xaxis, yaxis, indexing="xy")

        self.vel_x = np.zeros(self.x_coord.shape, dtype=np.float64)
        self.vel_y = np.zeros(self.x_coord.shape, dtype=np.float64)
        self.vel_z = np.zeros(self.x_coord.shape, dtype=np.float64)
        self.A = 0.1 * np.pi
        self.w = 2.0 * np.pi/10.0
        self.E = 0.25

    def compute_loop(self):
        """Computes and updates velocity fields"""
        while self.iteration < self.max_iterations:
            At = self.E * math.sin(self.w * self.iteration * self.timestep)
            Bt = 1.0 - 2.0 * At
            Ft = (At * self.x_coord*self.x_coord + Bt * self.x_coord) * np.pi
            fft = 2.0 * At * self.x_coord + Bt
            self.vel_x = -self.A * np.sin(Ft) * np.cos(np.pi*self.y_coord)
            self.vel_y =  self.A * np.cos(Ft) * np.sin(np.pi*self.y_coord)*fft
            self.iteration += 1

    def draw_matplotlib(self):
        """Draw with mathplotlib"""
        #plot the 'vel_x' field iso-contour lines
        fig, ax = plt.subplots()
        CS = ax.contour(self.vel_y, levels=10)
        ax.clabel(CS, inline=True, fontsize=10)
        ax.set_title('Vy iso-contours')
        plt.savefig(f'Vy-iso-contours.{self.iteration:03d}.png')
        #plot the velocity vectors sub-sampled
        fig1, ax1 = plt.subplots()
        stride = 10
        ax1.quiver(self.x_coord[::stride, ::stride], self.y_coord[::stride, ::stride],
                   self.vel_x[::stride, ::stride], self.vel_y[::stride, ::stride])
        ax1.set_title('Velocity vectors')
        plt.savefig(f'Velocity.{self.iteration:03d}.png')

class SimulationWithAscent(Simulation):
    """
    A specialized class to add in-situ visualization support

    Attributes
    ----------
    frequency : int
        the frequency at which in-situ operations take place
    """
    def __init__(self, resolution=(256,128), iterations=100, frequency=10):
        Simulation.__init__(self, resolution, iterations)
        self.delta_x = 2.0 / (self.xres - 1)
        self.frequency = frequency
        self.insitu = ascent.Ascent()
        self.actions = conduit.Node()
        self.mesh = conduit.Node()

    def compute_loop(self):
        """Computes and updates velocity fields and process in-situ requests"""
        while self.iteration < self.max_iterations:
            At = self.E * math.sin(self.w * self.iteration * self.timestep)
            Bt = 1.0 - 2.0 * At
            Ft = (At * self.x_coord*self.x_coord + Bt * self.x_coord) * np.pi
            fft = 2.0 * At * self.x_coord + Bt
            self.vel_x = -self.A * np.sin(Ft) * np.cos(np.pi*self.y_coord)
            self.vel_y =  self.A * np.cos(Ft) * np.sin(np.pi*self.y_coord)*fft
            self.iteration += 1
            self.mesh["state/cycle"] = self.iteration
            self.insitu.publish(self.mesh)
            self.insitu.execute(self.actions)

    def initialize_ascent(self):
        """Creates a Conduit node describing the mesh and add default action"""
        ascent_options = conduit.Node()
        output_path = "datasets"
        if not os.path.exists(output_path):
          os.makedirs(output_path)
        ascent_options["default_dir"] = output_path
        ascent_options["exceptions"] = "forward"
        # open Ascent
        self.insitu.open(ascent_options)
        
        self.mesh["coordsets/coords/type"] = "uniform"
        self.mesh["coordsets/coords/dims/i"] = self.xres
        self.mesh["coordsets/coords/dims/j"] = self.yres
        
        self.mesh["topologies/mesh/type"] = "uniform"
        self.mesh["topologies/mesh/coordset"] = "coords"

        self.mesh["coordsets/coords/origin/x"] = 0.0
        self.mesh["coordsets/coords/origin/y"] = 0.0
        
        self.mesh["coordsets/coords/spacing/dx"] = self.delta_x
        self.mesh["coordsets/coords/spacing/dy"] = self.delta_x
        
        #self.mesh["coordsets/coords/dims/k"] = 1
        #self.mesh["coordsets/coords/origin/z"] = 0.0
        #self.mesh["coordsets/coords/spacing/dz"] = 0.0
        
        self.mesh["fields/vx/association"] = "vertex"
        self.mesh["fields/vx/topology"] = "mesh"
        self.mesh["fields/vx/values"].set_external(self.vel_x.ravel())
        
        self.mesh["fields/vy/association"] = "vertex"
        self.mesh["fields/vy/topology"] = "mesh"
        self.mesh["fields/vy/values"].set_external(self.vel_y.ravel())
        
        self.mesh["fields/vz/association"] = "vertex"
        self.mesh["fields/vz/topology"] = "mesh"
        self.mesh["fields/vz/values"].set_external(self.vel_z.ravel())
        
        self.mesh["fields/Velocity/association"] = "vertex";
        self.mesh["fields/Velocity/topology"] = "mesh";
        self.mesh["fields/Velocity/values/u"].set_external(self.vel_x.ravel());
        self.mesh["fields/Velocity/values/v"].set_external(self.vel_x.ravel());
        self.mesh["fields/Velocity/values/w"].set_external(self.vel_z.ravel());
        
        # verify the mesh we created conforms to the blueprint
        verify_info = conduit.Node()
        if not conduit.blueprint.mesh.verify(self.mesh, verify_info):
            print("DoubleGyre Mesh Verify failed!")
        else:
            print("DoubleGyre Mesh verify success!")
            #print(self.mesh.to_yaml())
        
        self.add_act = self.actions.append()
        self.add_act["action"] = "add_triggers"
        
        self.triggers = self.add_act["triggers"]
        self.triggers["t1/params/condition"] = f'(cycle() % {self.frequency}) == 0'
        self.triggers["t1/params/actions_file"] = "save_images_actions.yaml"
        print(self.actions.to_yaml())

    def finalize_ascent(self):
        """Save the mesh to a blueprint HDF5 file and close"""
        self.mesh["state/cycle"] = self.iteration
        self.insitu.publish(self.mesh)
        hdf5_action = conduit.Node()
        add_extr = hdf5_action.append()
        # to save the derived vector magnitude, add the pipeline first
        add_extr["action"] = "add_pipelines"
        pipeline = add_extr["pipelines"]
        pipeline["pl1/f1/type"] = "vector_magnitude"
        pipeline["pl1/f1/params/field"] = "Velocity"
        pipeline["pl1/f1/params/output_name"] = "velocity_mag2d"

        add_extr = hdf5_action.append()
        add_extr["action"] = "add_extracts"
        extracts = add_extr["extracts"]
        extracts["e1/type"]="relay"
        extracts["e1/params/path"] = "datasets/mesh"
        extracts["e1/pipeline"] = "pl1"
        extracts["e1/params/protocol"] = "hdf5"
        print("saving grid data to HDF5 Blueprint file \'datasets/mesh*.root\'")
        self.insitu.execute(hdf5_action)
        self.insitu.close()

#sim = Simulation()
sim = SimulationWithAscent(iterations=100, frequency=10)
sim.initialize_ascent()
sim.compute_loop()
sim.draw_matplotlib()
sim.finalize_ascent()
